const ROWS = 100;
const COLS = 300;

const NUM_PARTICLES = ROWS * COLS;
const THICKNESS = Math.pow(80, 2);
const SPACING = 3;
const MARGIN = 100;
const COLOR = 220;
const DRAG = 0.95;
const EASE = 0.25;

let container: HTMLElement;
let particle = {
  vx: 0,
  vy: 0,
  x: 0,
  y: 0,
  ox: 0,
  oy: 0,
};
let canvas: HTMLCanvasElement;
let mouse;
let list: Array<typeof particle>;
let ctx: CanvasRenderingContext2D;
let tog;
let man;
let dx;
let dy;
let mx;
let my;
let d: number;
let t: number;
let f: number;
let a: number;
let b: number;
let i: number;
let n: number;
let w: number;
let h: number;
let p: number;
let s: number;
let r: number;
let c: number;

function init() {
  container = document.getElementById("container");
  canvas = document.createElement("canvas");

  ctx = canvas.getContext("2d");
  man = false;
  tog = true;

  list = [];

  w = canvas.width = COLS * SPACING + MARGIN * 2;
  h = canvas.height = ROWS * SPACING + MARGIN * 2;

  container.style.marginLeft = Math.round(w * -0.5) + "px";
  container.style.marginTop = Math.round(h * -0.5) + "px";

  for (i = 0; i < NUM_PARTICLES; i++) {
    const p: typeof particle = Object.create(particle);
    p.x = p.ox = MARGIN + SPACING * (i % COLS);
    p.y = p.oy = MARGIN + SPACING * Math.floor(i / COLS);

    list[i] = p;
  }

  container.addEventListener("mousemove", function (e) {
    const bounds = container.getBoundingClientRect();
    mx = e.clientX - bounds.left;
    my = e.clientY - bounds.top;
    man = true;
  });

  container.appendChild(canvas);
}

function step() {
  if ((tog = !tog)) {
    if (!man) {
      t = +new Date() * 0.001;
      mx = w * 0.5 + Math.cos(t * 2.1) * Math.cos(t * 0.9) * w * 0.45;
      my = h * 0.5 + Math.sin(t * 3.2) * Math.tan(Math.sin(t * 0.8)) * h * 0.45;
    }

    for (i = 0; i < NUM_PARTICLES; i++) {
      p = list[i];

      d = (dx = mx - p.x) * dx + (dy = my - p.y) * dy;
      f = -THICKNESS / d;

      if (d < THICKNESS) {
        t = Math.atan2(dy, dx);
        p.vx += f * Math.cos(t);
        p.vy += f * Math.sin(t);
      }

      p.x += (p.vx *= DRAG) + (p.ox - p.x) * EASE;
      p.y += (p.vy *= DRAG) + (p.oy - p.y) * EASE;
    }
  } else {
    b = (a = ctx.createImageData(w, h)).data;

    for (i = 0; i < NUM_PARTICLES; i++) {
      p = list[i];
      b[(n = (~~p.x + ~~p.y * w) * 4)] = COLOR;
      b[n + 1] = COLOR;
      b[n + 2] = COLOR;
      b[n + 3] = 255;
    }

    ctx.putImageData(a, 0, 0);
  }

  requestAnimationFrame(step);
}

init();
step();
